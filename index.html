<!DOCTYPE html>
<html>
<head>
    <title>Nexus Dynasty - Online</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: 'Segoe UI', sans-serif; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.5); padding: 15px; border-radius: 8px; pointer-events: none; user-select: none; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 10px; height: 10px; border: 2px solid white; border-radius: 50%; transform: translate(-50%, -50%); }
    </style>
</head>
<body>
    <div id="ui">
        <b>NEXUS DYNASTY</b><br>
        Déplacement: <b>Z Q S D</b><br>
        Saut: <b>ESPACE</b><br>
        <span id="status" style="color: yellow;">Connexion...</span>
    </div>
    <div id="crosshair"></div>

<script src="/socket.io/socket.io.js"></script>
<script type="importmap">{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js"}}</script>

<script type="module">
import * as THREE from 'three';

const socket = io();
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);
scene.fog = new THREE.Fog(0x87CEEB, 20, 90);

// --- CAMÉRA ---
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// --- LUMIÈRE ---
scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.6));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(50, 100, 50);
dirLight.castShadow = true;
scene.add(dirLight);

// --- MONDE (RELIEF & ARBRES) ---
function getHeight(x, z) {
    return (Math.sin(x * 0.05) * 2 + Math.cos(z * 0.05) * 2) + (Math.sin(x * 0.2) * 0.5);
}

const groundGeo = new THREE.PlaneGeometry(200, 200, 60, 60);
const count = groundGeo.attributes.position.count;
for (let i = 0; i < count; i++) {
    const x = groundGeo.attributes.position.getX(i);
    const z = groundGeo.attributes.position.getY(i);
    groundGeo.attributes.position.setZ(i, getHeight(x, z));
}
groundGeo.computeVertexNormals();
const ground = new THREE.Mesh(groundGeo, new THREE.MeshStandardMaterial({ color: 0x567d46 })); // Herbe
ground.rotation.x = -Math.PI / 2;
ground.receiveShadow = true;
scene.add(ground);

const trees = [];
const treeGeo = new THREE.CylinderGeometry(0.5, 0.8, 3, 6);
const leavesGeo = new THREE.ConeGeometry(2, 4, 8);
const trunkMat = new THREE.MeshStandardMaterial({color: 0x8B4513});
const leavesMat = new THREE.MeshStandardMaterial({color: 0x228B22});

function addTree(x, z) {
    const y = getHeight(x, z);
    const group = new THREE.Group();
    const trunk = new THREE.Mesh(treeGeo, trunkMat); trunk.position.y = 1.5;
    const leaves = new THREE.Mesh(leavesGeo, leavesMat); leaves.position.y = 4.5;
    group.add(trunk, leaves);
    group.position.set(x, y, z);
    scene.add(group);
    trees.push({x, z, radius: 1.5});
}

// On génère toujours les mêmes arbres (seed simple) pour que tout le monde voit les mêmes obstacles
for(let i=0; i<40; i++) {
    // Une formule pseudo-aléatoire pour que les arbres soient au même endroit sur les 2 ordis
    let pseudoX = Math.sin(i * 123) * 80;
    let pseudoZ = Math.cos(i * 456) * 80;
    addTree(pseudoX, pseudoZ);
}

// --- MULTIJOUEUR ---
const otherPlayers = {}; 
let myId = "";

// Créer le visuel d'un autre joueur
function createOtherPlayer(id, data) {
    const mesh = new THREE.Mesh(
        new THREE.CapsuleGeometry(0.5, 1.8, 4, 8), 
        new THREE.MeshStandardMaterial({color: data.color || 0xff0000})
    );
    mesh.position.set(data.x, data.y, data.z);
    mesh.castShadow = true;
    scene.add(mesh);
    otherPlayers[id] = mesh;
}

socket.on('connect', () => {
    document.getElementById('status').innerText = "Connecté !";
    document.getElementById('status').style.color = "lightgreen";
    myId = socket.id;
});

socket.on('currentPlayers', (players) => {
    Object.keys(players).forEach(id => {
        if (id !== myId && !otherPlayers[id]) {
            createOtherPlayer(id, players[id]);
        }
    });
});

socket.on('newPlayer', (data) => {
    createOtherPlayer(data.id, data);
});

socket.on('playerMoved', (data) => {
    if (otherPlayers[data.id]) {
        // On bouge l'autre joueur doucement vers sa nouvelle position
        otherPlayers[data.id].position.lerp(new THREE.Vector3(data.x, data.y, data.z), 0.5);
    }
});

socket.on('playerDisconnected', (id) => {
    if (otherPlayers[id]) {
        scene.remove(otherPlayers[id]);
        delete otherPlayers[id];
    }
});

// --- CONTROLES & PHYSIQUE LOCALE ---
let myPos = new THREE.Vector3(0, 10, 0);
let velocityY = 0;
let canJump = false;
let yaw = 0, pitch = 0;
const keys = {};

document.body.addEventListener('click', () => document.body.requestPointerLock());
document.addEventListener('mousemove', (e) => {
    if (document.pointerLockElement === document.body) {
        yaw -= e.movementX * 0.002;
        pitch -= e.movementY * 0.002;
        pitch = Math.max(-1.5, Math.min(1.5, pitch));
    }
});
window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

function animate() {
    requestAnimationFrame(animate);

    // 1. PHYSIQUE LOCALE
    if (document.pointerLockElement === document.body) {
        const dir = new THREE.Vector3();
        if (keys['KeyW']) dir.z -= 1;
        if (keys['KeyS']) dir.z += 1;
        if (keys['KeyA']) dir.x -= 1;
        if (keys['KeyD']) dir.x += 1;
        
        dir.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
        if (dir.length() > 0) dir.normalize().multiplyScalar(0.2); // Vitesse

        // Collisions Arbres
        let nextX = myPos.x + dir.x;
        let nextZ = myPos.z + dir.z;
        let collision = false;
        for(let t of trees) {
            if (Math.hypot(nextX - t.x, nextZ - t.z) < t.radius) collision = true;
        }
        if(!collision) {
            myPos.x = nextX;
            myPos.z = nextZ;
        }

        if (keys['Space'] && canJump) {
            velocityY = 0.5; // Force de saut
            canJump = false;
        }
    }

    // Gravité
    velocityY -= 0.02;
    myPos.y += velocityY;
    
    let groundH = getHeight(myPos.x, myPos.z);
    if (myPos.y < groundH + 1.5) {
        myPos.y = groundH + 1.5;
        velocityY = 0;
        canJump = true;
    }

    // 2. ENVOI AU SERVEUR (Le cœur du multijoueur)
    // On envoie notre position aux autres
    socket.emit('playerMovement', { x: myPos.x, y: myPos.y, z: myPos.z });

    // 3. MISE À JOUR CAMÉRA
    camera.position.copy(myPos);
    camera.position.y += 0.5; 
    camera.rotation.set(pitch, yaw, 0, 'YXZ');

    renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
