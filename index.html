<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Nexus Dynasty - Heritage</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: sans-serif; }
        .ui { position: absolute; inset: 0; pointer-events: none; }
        .panel { position: absolute; background: rgba(0,0,0,0.9); border: 2px solid #f1c40f; padding: 15px; color: white; pointer-events: auto; }
        #tuto { top: 10px; left: 10px; width: 280px; border-color: #27ae60; line-height: 1.4; }
        #stats { top: 10px; right: 10px; min-width: 150px; }
        #menu { bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; }
        .btn { padding: 10px 15px; background: #222; color: #f1c40f; border: 1px solid #f1c40f; cursor: pointer; font-weight: bold; }
        .btn:hover { background: #f1c40f; color: #000; }
        .bar { width: 100%; height: 10px; background: #333; margin-top: 5px; }
        #hp-fill { height: 100%; background: #e74c3c; width: 100%; transition: 0.3s; }
        #login-screen { position: absolute; inset: 0; background: #000; z-index: 1000; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        input { padding: 12px; border: 2px solid #f1c40f; background: #111; color: white; margin-bottom: 10px; text-align: center; }
    </style>
</head>
<body>

<div id="login-screen">
    <h1 style="color:#f1c40f; letter-spacing: 3px;">NEXUS DYNASTY</h1>
    <input type="text" id="psd" placeholder="NOM DU SEIGNEUR">
    <button class="btn" onclick="connect()">ENTRER DANS LE ROYAUME</button>
</div>

<div class="ui">
    <div id="tuto" class="panel">
        <b style="color:#27ae60">üìú GUIDE DE D√âPART</b><br>
        ‚Ä¢ <b style="color:#f1c40f">Arbres :</b> Approche-toi et appuie sur <b>ESPACE</b> pour r√©colter du bois.<br>
        ‚Ä¢ <b style="color:#f1c40f">Maison :</b> Trouve un endroit et ach√®te ton terrain [1].<br>
        ‚Ä¢ <b style="color:#f1c40f">Mineurs :</b> Recrute avec [3]. Ils cherchent le minerai et <b>doivent revenir</b> √† la maison pour te payer.<br>
        ‚Ä¢ <b style="color:#f1c40f">Upgrade :</b> Utilise ton bois et ton or avec [2] pour agrandir ta demeure.
    </div>

    <div id="stats" class="panel">
        <div style="color:#f1c40f">üí∞ Or: <span id="gold">0</span></div>
        <div style="color:#e67e22">ü™µ Bois: <span id="wood">0</span></div>
        <div style="margin-top:10px;">‚ù§Ô∏è Sant√©</div>
        <div class="bar"><div id="hp-fill"></div></div>
    </div>

    <div id="menu" class="panel">
        <button class="btn" onclick="buyHouse()">[1] MAISON (500üí∞)</button>
        <button class="btn" onclick="upgradeHouse()">[2] AM√âLIORER (800üí∞ + 100ü™µ)</button>
        <button class="btn" onclick="addWorker()">[3] MINEUR (200üí∞)</button>
    </div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script type="importmap">{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js"}}</script>

<script type="module">
import * as THREE from 'three';

const socket = io();
let scene, camera, renderer, player, myStats;
const keys = {}, trees = [], ores = [], workers = [], enemies = [];

window.connect = () => {
    const p = document.getElementById('psd').value;
    if(p) socket.emit('login', { pseudo: p });
};

socket.on('initData', (data) => {
    myStats = data.me;
    document.getElementById('login-screen').style.display = 'none';
    init();
});

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a10);
    camera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 0.1, 1000);
    
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    const sun = new THREE.DirectionalLight(0xffffff, 0.8);
    sun.position.set(10, 50, 10);
    scene.add(sun);

    // SOL UNIQUE
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(800, 800), new THREE.MeshStandardMaterial({color: 0x1a2e0a}));
    ground.rotation.x = -Math.PI/2;
    scene.add(ground);

    player = new THREE.Mesh(new THREE.CapsuleGeometry(0.6, 1.2), new THREE.MeshStandardMaterial({color: 0x00f2ff}));
    player.position.y = 1;
    scene.add(player);

    // G√âN√âRATION MONDE
    for(let i=0; i<60; i++) spawnTree();
    for(let i=0; i<20; i++) spawnOre();
    for(let i=0; i<6; i++) spawnEnemy();
    
    if(myStats.house.built) buildHouseVisual();

    animate();
}

function spawnTree() {
    const t = new THREE.Group();
    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 4), new THREE.MeshStandardMaterial({color: 0x4b2c20}));
    trunk.position.y = 2; t.add(trunk);
    const leaves = new THREE.Mesh(new THREE.IcosahedronGeometry(2.5, 1), new THREE.MeshStandardMaterial({color: 0x2d5a27}));
    leaves.position.y = 5; t.add(leaves);
    
    t.position.set(Math.random()*400-200, 0, Math.random()*400-200);
    if(t.position.length() < 40) t.position.x += 60; // √âvite le spawn au centre
    t.userData = { hp: 5 };
    scene.add(t); trees.push(t);
}

function spawnOre() {
    const o = new THREE.Mesh(new THREE.DodecahedronGeometry(1), new THREE.MeshStandardMaterial({color: 0x7f8c8d, metalness: 0.8}));
    o.position.set(Math.random()*80-40, 0.5, Math.random()*80-40);
    scene.add(o); ores.push(o);
}

function spawnEnemy() {
    const e = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), new THREE.MeshStandardMaterial({color: 0xc0392b}));
    e.position.set(Math.random()*300-150, 1, Math.random()*300-150);
    scene.add(e); enemies.push({mesh: e, hp: 50});
}

function buildHouseVisual() {
    const h = new THREE.Group();
    const body = new THREE.Mesh(new THREE.BoxGeometry(12, 10, 12), new THREE.MeshStandardMaterial({color: 0xecf0f1}));
    body.position.y = 5; h.add(body);
    const roof = new THREE.Mesh(new THREE.ConeGeometry(10, 6, 4), new THREE.MeshStandardMaterial({color: 0x2c3e50}));
    roof.position.y = 13; roof.rotation.y = Math.PI/4; h.add(roof);
    
    h.position.set(myStats.house.x, 0, myStats.house.z);
    scene.add(h);
    myStats.house.mesh = h;
}

window.buyHouse = () => {
    if(!myStats.house.built && myStats.gold >= 500) {
        myStats.gold -= 500;
        myStats.house.built = true;
        myStats.house.x = player.position.x;
        myStats.house.z = player.position.z;
        buildHouseVisual();
        save();
    }
};

window.upgradeHouse = () => {
    if(myStats.house.built && myStats.gold >= 800 && myStats.wood >= 100) {
        myStats.gold -= 800; myStats.wood -= 100;
        myStats.house.lvl++;
        myStats.house.mesh.scale.set(1 + myStats.house.lvl*0.1, 1, 1 + myStats.house.lvl*0.1);
        save();
    }
};

window.addWorker = () => {
    if(myStats.house.built && myStats.gold >= 200) {
        myStats.gold -= 200;
        myStats.house.workers++;
        const m = new THREE.Mesh(new THREE.SphereGeometry(0.6), new THREE.MeshStandardMaterial({color: 0xf1c40f}));
        m.position.copy(myStats.house.mesh.position);
        scene.add(m);
        workers.push({ mesh: m, state: 'find', target: null });
        save();
    }
};

function save() { socket.emit('updatePlayer', myStats); }

function animate() {
    requestAnimationFrame(animate);
    
    // D√©placement
    const s = 0.45;
    if(keys['KeyW']) player.position.z -= s; if(keys['KeyS']) player.position.z += s;
    if(keys['KeyA']) player.position.x -= s; if(keys['KeyD']) player.position.x += s;

    // IA MINEURS (D√©p√¥t physique √† la maison)
    workers.forEach(w => {
        if(w.state === 'find') {
            w.target = ores[Math.floor(Math.random()*ores.length)];
            w.state = 'move';
        } else if(w.state === 'move') {
            w.mesh.position.lerp(w.target.position, 0.03);
            if(w.mesh.position.distanceTo(w.target.position) < 1.5) w.state = 'return';
        } else if(w.state === 'return') {
            w.mesh.position.lerp(myStats.house.mesh.position, 0.03);
            if(w.mesh.position.distanceTo(myStats.house.mesh.position) < 2) {
                myStats.gold += 25;
                w.state = 'find';
                save();
            }
        }
    });

    // R√âCOLTE BOIS
    if(keys['Space']) {
        trees.forEach(t => {
            if(t.visible && player.position.distanceTo(t.position) < 5) {
                t.userData.hp -= 0.05;
                if(t.userData.hp <= 0) {
                    t.visible = false;
                    myStats.wood += 20;
                    save();
                }
            }
        });
    }

    // ENNEMIS (IA Simple)
    enemies.forEach(e => {
        const dist = player.position.distanceTo(e.mesh.position);
        if(dist < 20) {
            e.mesh.position.lerp(player.position, 0.015);
            if(dist < 2.5) myStats.hp -= 0.2;
        }
    });

    // Cam√©ra
    camera.position.set(player.position.x, player.position.y + 45, player.position.z + 35);
    camera.lookAt(player.position);
    
    // UI
    document.getElementById('gold').innerText = Math.floor(myStats.gold);
    document.getElementById('wood').innerText = Math.floor(myStats.wood);
    document.getElementById('hp-fill').style.width = myStats.hp + "%";
    
    renderer.render(scene, camera);
}

window.onkeydown = e => keys[e.code] = true;
window.onkeyup = e => keys[e.code] = false;
window.onresize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
};
</script>
</body>
</html>
