<!DOCTYPE html>
<html>
<head>
    <title>Nexus Dynasty - Evolution</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: 'Segoe UI', sans-serif; }
        #gui { position: absolute; top: 20px; left: 20px; color: white; background: rgba(0,0,0,0.5); padding: 15px; border-radius: 10px; border-left: 5px solid #4CAF50; pointer-events: none; }
        #leaderboard { position: absolute; top: 20px; right: 20px; color: #FFD700; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; text-align: right; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="gui">
        <b style="font-size: 1.2em;">NEXUS DYNASTY</b><br>
        Fragments: <span id="score">0</span><br>
        <i>Z,Q,S,D pour bouger | Souris pour regarder</i>
    </div>
    <div id="leaderboard">CLASSEMENT<br><span id="list">Joueur: 0</span></div>

<script src="/socket.io/socket.io.js"></script>
<script type="importmap">{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js"}}</script>

<script type="module">
import * as THREE from 'three';

const socket = io();
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x6eb1ff); // Ciel clair
scene.fog = new THREE.Fog(0x6eb1ff, 20, 80);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// --- LUMIÈRES ---
const ambient = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambient);
const sun = new THREE.DirectionalLight(0xffffff, 1);
sun.position.set(10, 20, 10);
sun.castShadow = true;
scene.add(sun);

// --- TERRAIN ET DÉCOR ---
function createTree(x, z) {
    const group = new THREE.Group();
    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 1.5), new THREE.MeshStandardMaterial({color: 0x5d4037}));
    trunk.position.y = 0.75;
    const leaves = new THREE.Mesh(new THREE.ConeGeometry(1, 2, 8), new THREE.MeshStandardMaterial({color: 0x2e7d32}));
    leaves.position.y = 2.5;
    group.add(trunk, leaves);
    group.position.set(x, 0, z);
    scene.add(group);
}

// Créer un sol avec des couleurs (Biome herbe / sable)
const floorGeo = new THREE.PlaneGeometry(100, 100);
const floorMat = new THREE.MeshStandardMaterial({ color: 0x7cb342 });
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI / 2;
floor.receiveShadow = true;
scene.add(floor);

for(let i=0; i<30; i++) createTree(Math.random()*80-40, Math.random()*80-40);

// --- JOUEUR ET CAMÉRA ---
let myPlayer, myModel, pitch = 0, yaw = 0;
const keys = {};

// On capture la souris pour la caméra
document.body.addEventListener('click', () => document.body.requestPointerLock());
document.addEventListener('mousemove', (e) => {
    if (document.pointerLockElement === document.body) {
        yaw -= e.movementX * 0.002;
        pitch -= e.movementY * 0.002;
        pitch = Math.max(-Math.PI/3, Math.min(Math.PI/3, pitch));
    }
});

socket.on('currentPlayers', (list) => {
    Object.keys(list).forEach(id => {
        const p = list[id];
        const group = new THREE.Group();
        const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.4, 1), new THREE.MeshStandardMaterial({color: p.color}));
        body.position.y = 1;
        group.add(body);
        scene.add(group);
        if(id === socket.id) myPlayer = group;
    });
});

window.onkeydown = e => keys[e.key.toLowerCase()] = true;
window.onkeyup = e => keys[e.key.toLowerCase()] = false;

function animate() {
    requestAnimationFrame(animate);
    
    if(myPlayer) {
        const speed = 0.15;
        if(keys['z']) myPlayer.translateZ(-speed);
        if(keys['s']) myPlayer.translateZ(speed);
        if(keys['q']) myPlayer.translateX(-speed);
        if(keys['d']) myPlayer.translateX(speed);

        myPlayer.rotation.y = yaw; // Le corps tourne avec la souris

        // La caméra suit le joueur
        const camOffset = new THREE.Vector3(0, 2, 5).applyQuaternion(myPlayer.quaternion);
        camera.position.lerp(myPlayer.position.clone().add(camOffset), 0.1);
        camera.lookAt(myPlayer.position.clone().add(new THREE.Vector3(0, 1.5, 0)));

        socket.emit('playerMovement', {x: myPlayer.position.x, z: myPlayer.position.z});
    }
    
    renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
